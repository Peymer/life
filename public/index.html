<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="utf-8" />
    <title>Фронт для микросервиса "Игра 'Жизнь'"</title>
</head>

<body>
    <input id="sizeX" value="10" /> * <input id="sizeY" value="10" /><br />
    <input type="checkbox" id="rnd" />Случайное заполнение<br />
    <button id="startId" onclick="Start()">Start</button>
    <button id="stopId" onclick="Stop()" disabled="true">Stop</button><br />
    Поколение:<label id="Generation"></label><br />
    <canvas id="myCanvas" width="1200" height="800" style="background: aqua; border: 0cap;"></canvas><br />
    <button id="nextG" onclick="Next()" disabled="true">Следующее</button><br />

    <script>
        var sizeX, sizeY, pole, lenX, lenY, timer, Generation

        const generationHTML = document.getElementById("Generation")
        const canvas = document.getElementById("myCanvas");
        const ctx = canvas.getContext("2d");

        sizeX = document.getElementById("sizeX").value
        sizeY = document.getElementById("sizeY").value
        lenX = canvas.width / sizeX
        lenY = canvas.height / sizeY
        Generation = 0
        let rnd = document.getElementById("rnd").checked
        pole = init(sizeX, sizeY)
        generationHTML.innerText = Generation;
        netOnCanvas(ctx)
        canvas.addEventListener('click', Click)


        // запуск
        function Start() {
            // sizeX = document.getElementById("sizeX").value
            // sizeY = document.getElementById("sizeY").value
            // lenX = canvas.width / sizeX
            // lenY = canvas.height / sizeY
            // Generation = 0
            // pole = init(sizeX, sizeY)
            // generationHTML.innerText = Generation;
            canvas.removeEventListener("click", Click)

            if (document.getElementById("rnd").checked) {
                pole = init(sizeX, sizeY, true)
                document.getElementById("rnd").checked = false
            }

            drawOnCanvas(ctx, pole)

            timer = setInterval(() => Next(), 2000); // новое поколение через 2 секунды (2000мс=2*1000с)
            document.getElementById("startId").disabled = true
            document.getElementById("stopId").disabled = false
            document.getElementById("nextG").disabled = false
        }

        // остановка таймера
        function Stop() {
            clearInterval(timer)
            document.getElementById("startId").disabled = false
            document.getElementById("stopId").disabled = true
            document.getElementById("nextG").disabled = true
            canvas.addEventListener('click', Click)
        }

        // следующее поколение
        async function Next() {
            // generationHTML.innerText = Generation++ // Для отладки
            // pole = init(sizeX, sizeY)                // Для отладки

            let q = await fetch("http://192.168.133.235:5555/", {
                "redirect": 'follow',
                "mode": 'cors',
                "method": "POST",
                "body": JSON.stringify({ gen: Generation, sizeX: sizeX, sizeY: sizeY, pole: pole })
            })
            let result = await q.json();

            Generation = result.gen
            generationHTML.innerText = Generation
            pole = result.pole

            drawOnCanvas(ctx, pole)
        }


        // Рисует жителя в клетке (x,y)
        function drawСitizen(x, y, r = Math.min(lenX / 2, lenY / 2)) {
            let C = calcCenter(x, y)
            ctx.beginPath();
            ctx.arc(C.x, C.y, r, 0, 2 * Math.PI);
            ctx.fill();
        }

        // Стирает жителя в клетке (x,y)
        function clearСitizen(x, y, r = Math.min(lenX / 2, lenY / 2)) {
            let C = calcCenter(x, y)
            ctx.beginPath();
            ctx.fillStyle = "aqua"
            ctx.arc(C.x, C.y, r, 0, 2 * Math.PI);
            ctx.fill();
        }

        // вычисляет координаты центра окружности в клетке (x,y)
        function calcCenter(x, y) {
            let center = {
                "x": x * lenX + lenX / 2,
                "y": y * lenY + lenY / 2
            };
            return center;
        }

        //выводит все pole на canvas
        function drawOnCanvas(ctx, gen) {
            netOnCanvas(ctx)
            let x = 0;
            gen.forEach(el => {
                let y = 0;
                el.forEach(cit => {
                    if (cit)
                        drawСitizen(x, y++);
                    else y++;
                })
                x++;
            });
        }

        //рисует сетку
        function netOnCanvas(ctx) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = "black";
            ctx.beginPath();

            for (let i = 0; i < sizeX; i++) {
                ctx.moveTo((i + 1) * lenX, 0);
                ctx.lineTo((i + 1) * lenX, canvas.height);
                // ctx.stroke();
            }
            for (let j = 0; j < sizeY; j++) {
                ctx.moveTo(0, (j + 1) * lenY);
                ctx.lineTo(canvas.width, (j + 1) * lenY);
                // ctx.stroke();
            }
            ctx.stroke();
        }

        // Случайным образо заполняет pole
        function init(statX, startY, random = false) {
            let p = [];
            for (let i = 0; i < sizeX; i++) {
                let s1 = [];
                for (let j = 0; j < sizeY; j++)
                    if (random)
                        s1.push(Math.random() < 0.5 ? 1 : 0);
                    else
                        s1.push(0)
                p.push(s1);
            }
            return p;
        }

        //щелчек мышки по canvas
        function Click(e) {
            let x = Math.trunc(e.offsetX / lenX)
            let y = Math.trunc(e.offsetY / lenY)
            if (pole[x][y] === 0) {
                pole[x][y] = 1
                drawСitizen(x, y)
            }
            else {
                pole[x][y] = 0
                clearСitizen(x, y)
            }
        }
    </script>
</body>

</html>