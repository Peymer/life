<!DOCTYPE html>
<html lang="ru">

<head>
    <meta charset="utf-8" />
    <title>Фронт для микросервиса "Игра 'Жизнь'"</title>
</head>

<body>
    <input id="sizeX" /> * <input id="sizeY" /><br />
    <button id="startId" onclick="Start()">Start</button> <button id="stopId" onclick="Stop()"
        disabled>Stop</button><br />

    Поколение:<div id="Generation"></div>
    <canvas id="myCanvas" width="500" height="400" style="background: aqua; border: 0cap;"></canvas><br />
    <button onclick="Next()">>>></button>

    <script>
        var sizeX, sizeY, pole, lenX, lenY, timer
        var Generation = 0;

        const generationHTML = document.getElementById("Generation")
        const canvas = document.getElementById("myCanvas");
        const ctx = canvas.getContext("2d");

        // запуск
        function Start() {
            sizeX = document.getElementById("sizeX").value
            sizeY = document.getElementById("sizeY").value
            lenX = canvas.width / sizeX
            lenY = canvas.height / sizeY

            pole = init(sizeX, sizeY)
            generationHTML.innerText = Generation++;
            drawOnCanvas(ctx, pole)

            timer = setInterval(() => Next(), 2000); // новое поколение через 2 секунды (2000мс=2*1000с)
            document.getElementById("startId").disabled = true
            document.getElementById("stopId").disabled = false
        }

        // остановка таймера
        function Stop() {
            clearInterval(timer)
            document.getElementById("startId").disabled = false
            document.getElementById("stopId").disabled = true
        }

        // следующее поколение
        function Next() {
            generationHTML.innerText = Generation++;
            pole = init(sizeX, sizeY)

            drawOnCanvas(ctx, pole)
        }


        // Рисует жителя в клетке (x,y)
        function drawСitizen(x, y, r = Math.min(lenX / 2, lenY / 2)) {
            let C = calcCenter(x, y)
            ctx.beginPath();
            ctx.arc(C.x, C.y, r, 0, 2 * Math.PI);
            ctx.fill();
        }

        // вычисляет координаты центра окружности в клетке (x,y)
        function calcCenter(x, y) {
            let center = {
                "x": x * lenX + lenX / 2,
                "y": y * lenY + lenY / 2
            };
            return center;
        }

        //выводит все pole на canvas
        function drawOnCanvas(ctx, gen) {
            netOnCanvas(ctx)
            let x = 0;
            gen.forEach(el => {
                let y = 0;
                el.forEach(cit => {
                    if (cit)
                        drawСitizen(x, y++);
                    else y++;
                })
                x++;
            });
        }

        //рисует сетку
        function netOnCanvas(ctx) {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = "black";
            ctx.beginPath();

            for (let i = 0; i < sizeX; i++) {
                ctx.moveTo((i + 1) * lenX, 0);
                ctx.lineTo((i + 1) * lenX, canvas.height);
                // ctx.stroke();
            }
            for (let j = 0; j < sizeY; j++) {
                ctx.moveTo(0, (j + 1) * lenY);
                ctx.lineTo(canvas.width, (j + 1) * lenY);
                // ctx.stroke();
            }
            ctx.stroke();
        }

        // Случайным образо заполняет pole
        function init(statX, startY) {
            let pole = [];
            for (let i = 0; i < sizeX; i++) {
                let s1 = [];
                for (let j = 0; j < sizeY; j++)
                    s1.push(Math.random() < 0.3 ? 1 : 0);
                pole.push(s1);
            }
            return pole;
        }
    </script>
</body>

</html>